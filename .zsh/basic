#
# basic config with nifty functions
#

# If running interactively, then:
if [ "$PS1" ]; then
	# clean all aliases
	unhash -am '*'
	
	# nice prompt
	export PS1='[%n@%m:%~]$ '
	# nice ri
	export RI="--no-pager -f ansi"

	
	# alias section
	alias la='ls -a'
	alias ll='ls -lh'
	alias l='ls -lah'
	# with mmv u can rename multiple files. mmv *.text *.txt
	alias mmv='noglob zmv -W'
	autoload -U zmv
	
	# set different colors on STDERR
	autoload -U colors
	colors
	#exec 2>>(while read line; do
	#	print "$fg[blue]${(q)line}" > /dev/tty; done & )
	#print "$bg[black]$fg[red]${(q)line}" > /dev/tty; done &)

	# complist section
	zmodload -i zsh/complist 
	
	setopt autocd                  # change to dirs without cd
	setopt extendedglob            # weird & wacky pattern matching - yay zsh!
	setopt completeinword          # not just at the end
	setopt alwaystoend             # when complete from middle, move cursor
	setopt nopromptcr              # don't add \n which overwrites cmds with no \n
	setopt histverify              # when using ! cmds, confirm first
	setopt interactivecomments     # escape commands so i can use them later
	setopt printexitvalue          # alert me if something's failed
	
	# history related stuff.
	export HISTSIZE=5000
	export SAVEHIST=5000
	export HISTFILE=~/.zsh_history
	setopt hist_ignore_dups        # ignore same commands run twice+
	setopt appendhistory           # don't overwrite history 

	# use ssh for rysnc
	export RSYNC_RSH=ssh

	export VISUAL=vim
	export EDITOR=$VISUAL
	export PAGER=less

	# nifty aliases
	alias -g L='2>&1 | less'
	alias -g G='| grep'
	alias -g W='|wc -l'
	alias -g S='|sort'
	# file extension aliases
	alias -s zip="zipinfo"
	alias -s txt "less"
	# quick edit
	alias z="$EDITOR ~/.zshrc"

#
# completion tweaking
#

# complete hostnames out of ssh's ~/.ssh/known_hosts
	autoload -U compinit; compinit
	zstyle ':completion:*' use-cache on
	zstyle ':completion:*' users resolve
#     hosts=(${${${${(f)"$(<$HOME/.ssh/known_hosts)"}:#[0-9]*}%%\ *}%%,*})
#     zstyle ':completion:*:hosts' hosts $hosts

# use dircolours in completion listings
	zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
fi

# more completion options, see zsh manpage
#     zstyle ':completion:*' menu select=15 #show menu if >=15 possibilities 
#     zstyle ':completion:*' completer _complete _match _approximate
#     zstyle ':completion:*:match:*' original only
#     zstyle ':completion:*:approximate:*' max-errors 1 numeric
#     zstyle ':completion:*' auto-description 'Specify: %d'
#     zstyle ':completion:*' format 'Completing %d'
#     zstyle ':completion:*' verbose true
#     zstyle ':completion:*:functions' ignored-patterns '_*'
#     zstyle ':completion:*:*:(^rm):*:*files' ignored-patterns \
#        '*?.(o|c~|zwc)' '*?~'


# functions

#Author: Copyright (c) 2005 Eric Mangold - teratorn (at) world (dash) net (dot) net
#License: MIT. http://www.opensource.org/licenses/mit-license.html
extract_archive () {
	local old_dirs current_dirs lower
	lower=${(L)1}
	old_dirs=( *(N/) )
	if [[ $lower == *.tar.gz || $lower == *.tgz ]]; then
	    tar zxfv $1
	elif [[ $lower == *.gz ]]; then
	    gunzip $1
	elif [[ $lower == *.tar.bz2 || $lower == *.tbz ]]; then
	    bunzip2 -c $1 | tar xfv -
	elif [[ $lower == *.bz2 ]]; then
	    bunzip2 $1
	elif [[ $lower == *.zip ]]; then
	    unzip $1
	elif [[ $lower == *.rar ]]; then
	    unrar e $1
	elif [[ $lower == *.tar ]]; then
	    tar xfv $1
	elif [[ $lower == *.lha ]]; then
	    lha e $1
	else
	    print "Unknown archive type: $1"
	    return 1
	fi
	# Change in to the newly created directory, and
	# list the directory contents, if there is one.
	current_dirs=( *(N/) )
	for i in {1..${#current_dirs}}; do
	    if [[ $current_dirs[$i] != $old_dirs[$i] ]]; then
	        cd $current_dirs[$i]
	        ls
	        break
	    fi
	done
}
alias ex=extract_archive
compdef '_files -g "*.gz *.tgz *.bz2 *.tbz *.zip *.rar *.tar *.lha"' extract_archive
# 
# Give us a root shell, or run the command with sudo.
# Expands command aliases first (cool!)
smart_sudo () {
	if [[ -n $1 ]]; then
	    #test if the first parameter is a alias
	    if [[ -n $aliases[$1] ]]; then
	        #if so, substitute the real command
	        sudo ${=aliases[$1]} $argv[2,-1]
	    else
	        #else just run sudo as is
	        sudo $argv
	    fi
	else
	    #if no parameters were given, then assume we want a root shell
	    sudo -s
	fi
}
alias s=smart_sudo
compdef _sudo smart_sudo
#
# big-endian or little-endian ? 
# Tested on: Mac G4 and macbbook.
isbig () {
	isBIG=`/usr/bin/perl -e 'printf(unpack("h*", pack("s", 1)) =~ /01/);'`
	if [ $isBIG -eq 1 ]; then 
		print "BIG_ENDIAN"; 
	#elif [ $isBig -eq 1000 ]; then
	else
		print "LITTLE_ENDIAN"
	fi
}
